#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> 
#include <getopt.h>
#include <time.h>
#include <string.h>
#include "libMems/Tuiuiu/list.h"
#include "libMems/Tuiuiu/util.h"
#include "libMems/Tuiuiu/mono_and_multi_commons.h"
#define BEGIN(i, bin, tui_z, N) (i + N - ((bin + 1) << tui_z))
#define END(begin, w, bin_size) (begin + w + bin_size - 1)
#define MAX(a, b) (a > b ? a : b)
#define PLCS_type short

inline void CountBins(int d, int e, int p, int bins[], itree **l)
{
   int bin, binstop;
   for ( bin = d >> tui_z, binstop = ((d + e) >> tui_z)+1; bin < binstop; bin ++ )
     if (bin > tui_lastbin) {
       bins[bin]++;
       tui_lastbin = bin;
       if (bins[bin] == p){
	 AddTree(bin, l);
	 }
     }
}


inline void UncountBins(int d, int e, int p, int bins[], itree **l)
{
   int bin, binstop;
   //   printf("removing %d %d\n",d,removed);		/* DEB */
   for ( bin = d >> tui_z, binstop = ((d + e) >> tui_z)+1; bin < binstop; bin ++ )
     if (bin > tui_lastbin) {
       bins[bin]--;
       tui_lastbin = bin;
       if (bins[bin] == p - 1){
	 if(bin == 344877 || bin == 344878) {			    /* DEB */
	   fprintf(stderr,"removing %d\n",bin); /* DEB */
	   if((*l)->left) fprintf(stderr,"left = %d\n",(*l)->left->bin);  /* DEB */
	   if((*l)->right) fprintf(stderr,"right = %d\n",(*l)->right->bin);  /* DEB */
	 }					     /* DEB */
	 //	 fprintf(stderr,"avant l->bin = %d\n", (*l)->bin);	/* DEB */
	 RemoveTree(bin, l);
	 //	 if(*l) fprintf(stderr,"apres l->bin = %d\n", (*l)->bin); /* DEB */
       }
     }
}

void ReportPgram(int begin, int end, tlist **result, empty_block goodWindows[], int curr_parall_min, int curr_parall_max, int curr_pass_num)
{
  int curr_parall;
  /* EMPTY BLOCK */
  // goodWindows update when the current window is kept
  for(curr_parall = curr_parall_min; curr_parall <=curr_parall_max; curr_parall++){
    (goodWindows[curr_parall]).notEmpty=1;
    (goodWindows[curr_parall]).pass_num=curr_pass_num;
  }
  /**/

  end--;
  if (*result != NULL)
    {
      if ((*result)->end >= begin)
	{
	  (*result)->end = end;
	  return;
	}
    } 
  *result = Add(*result, begin, end);
}    


/*
 * returns the time in seconds since the begining of the processuss
 */
inline double cpuTime()
{
  return clock() / (double) CLOCKS_PER_SEC; //time(NULL);
}

/*
  set position just after the first symbol read
  @returns the first non space symbol read
*/
char firstNonSpaceRead(FILE *file){
  char base;
  for(base = (char) fgetc(file); base == ' ' || base == '\n' || base=='\t'; base = (char) fgetc(file)) 
    if(base== EOF){
      return EOF;
    }
  return base;
}


/**
  Read all lines starting with > (allowing spaces before the >
  Set the file offset at the beginning of the first line that doesn't start with a >
  Fill the variable name with the value of the comment read. 
  If no comment is read, file name with the defaultmessage value
  @returns 1 if at least one line starting with > was read, else return 0
**/
int readcomments(FILE *file, char **name, char * default_message){
  long before_comments = ftell(file);
  int sizename=0;
  const int chunk=128;
  
       
  char base = firstNonSpaceRead(file);
  if(base == EOF) return 0;
  
  if(base!='>'){		/* no comment :-) */
    *name = (char *) malloc(128*sizeof(char));
    strcpy (*name, default_message);
    fseek(file, before_comments, SEEK_SET); /* set the offset at the beggining of the line */
    return 0;
  }

  // if we are here, at least one comment was read

  while(1){
    for ( base = (char) fgetc(file);
	  base != '\n';
	  base = (char) fgetc(file) ) {
      if(base == EOF) break;
      if (sizename % chunk == 0)
	*name = (char *) realloc( *name, (sizename+chunk)*sizeof(char) );
      (*name)[sizename] = base;
      sizename++;
    }

    // check next line
    before_comments = ftell(file);
    base = firstNonSpaceRead(file);
    if(base!='>') {			      /* the real sequence starts */
      fseek(file, before_comments, SEEK_SET); /* set the offset at the beggining of the line */
      break;
    }
  }
  *name = (char *) realloc( *name, (sizename+1)*sizeof(char) );
  (*name)[sizename] = '\0';
  
  return 1;
}

int readsequence(FILE *file, char**seq, char **name){
  char base;
  int sizeseq;
  const int chunk=128;
  
  sizeseq = 0;
  *seq = NULL;
  *name = NULL;

  readcomments(file, name, "Comment was missing, this one was generated by tuiuiu");
  
  
  for ( base = toupper((char) fgetc(file));
	base != '>' && base != EOF;
	base = toupper((char) fgetc(file)) )
    if ( base == 'A' || base == 'C' || base == 'T'
	 || base == 'G' || base == 'N') {  /* N means any base */
      if (sizeseq % chunk == 0)
	*seq = (char *) realloc( *seq, (sizeseq+chunk)*sizeof(char) );
      (*seq)[sizeseq] = base;
      sizeseq++;
    }
  
  *seq = (char *) realloc( *seq, (sizeseq+1)*sizeof(char) );
  (*seq)[sizeseq] = '\0';
  
  if (base!=EOF) ungetc(base,file);	/* to allow reading multifasta files */
  
  //if(sizeseq>0) printf("%s: %d bases\n", *name, sizeseq);

  return sizeseq;
}

inline char reverse (const char c){
  switch (c){
  case 'A':
  case 'a': return 'T';
  case 'C':
  case 'c': return 'G';
  case 'G':
  case 'g': return 'C';
  case 'T':
  case 't': return 'A';
  }
  return 'N';
}

// Read a sequence of length N. 
// returns a sequence of length 2N: 
//   - From 0 to N-1: direct sequence
//   - From N to 2N-1: reverse complemented sequence
// For instance if ATACC if given, this function returns ATACCGGTAT
int readsequenceAndReverse(FILE *file, char**seq, char **name){
  char base;
  int i, sizeseq;
  const int chunk=128;
  
  sizeseq = 0;
  *seq = NULL;
  *name = NULL;

  readcomments(file, name, "Comment was missing, this one was generated by tuiuiu");
  
  
  for ( base = toupper((char) fgetc(file));
	base != '>' && base != EOF;
	base = toupper((char) fgetc(file)) )
    if ( base == 'A' || base == 'C' || base == 'T'
	 || base == 'G' || base == 'N') {  /* N means any base */
      if (sizeseq % chunk == 0)
	*seq = (char *) realloc( *seq, (sizeseq+chunk)*sizeof(char) );
      (*seq)[sizeseq] = base;
      sizeseq++;
    }
  
  /// 
  // store the reverse complement of the sequence
  *seq = (char *) realloc( *seq, (2*sizeseq)*sizeof(char) );
  
  for (i=0;i<sizeseq;i++) (*seq)[i+sizeseq] = reverse ((*seq)[sizeseq-i-1]);

  sizeseq *=2;

  *seq = (char *) realloc( *seq, (sizeseq+1)*sizeof(char) );
  (*seq)[sizeseq] = '\0';
  
  if (base!=EOF) ungetc(base,file);	/* to allow reading multifasta files */
  
  // if(sizeseq>0) printf("%s: %d bases\n", *name, sizeseq);

  // printf("%s\n", *seq);		/* DEB */

  return sizeseq;
}


/**
  jump all lines starting with > (allowing spaces before the >
  @returns 1 if at least one line starting with > was read, else return 0
**/
int jumpcomments(FILE *file){
  long before_comments = ftell(file);
  
       
  char base = firstNonSpaceRead(file);
  if(base == EOF) return 0;
  
  if(base!='>'){		/* no comment :-) */
    fseek(file, before_comments, SEEK_SET); /* set the offset at the beggining of the line */
    return 0;
  }

  // if we are here, at least one comment was read

  while(1){
    for ( base = (char) fgetc(file);
	  base != '\n';
	  base = (char) fgetc(file) ) {
      if(base == EOF) break;
    }

    // check next line
    before_comments = ftell(file);
    base = firstNonSpaceRead(file);
    if(base!='>') {			      /* the real sequence starts */
      fseek(file, before_comments, SEEK_SET); /* set the offset at the beggining of the line */
      break;
    }
  }
  
  return 1;
}

/**
 * Returns 0 if no other sequence are after the current offset in file, else return the length of the sequence
 */
int isThereASequence (FILE *file){
  char base;
  int sizeseq;
  const long before_comments = ftell(file);
  
  sizeseq = 0;

  jumpcomments(file);
  

  for ( base = toupper((char) fgetc(file));
	base != '>' && base != EOF;
	base = toupper((char) fgetc(file)) )
    if ( base == 'A' || base == 'C' || base == 'T'
	 || base == 'G' || base == 'N') {  /* N means any base */
      sizeseq++;
    }
  
  if (base!=EOF) ungetc(base,file);	/* to allow reading multifasta files */
  fseek(file, before_comments, SEEK_SET);
  return sizeseq;
}

/**
 * Returns the number of number of elements in the tree that are good parallelograms
 */
int Nelems(int *begin, int *end, itree *l, int i, int w, int bin_size, int N, empty_block goodWindows[], int curr_pass_num, int curr_parall_min, int curr_parall_max)
{
  int result, n, intervalSize, beg_currBin, real_end_currBin, parall_ind, j, neb, begTemp;

  if (l == NULL)
    return 0;
  else
    {
      result = Nelems(begin, end, l->right, i, w, bin_size, N, goodWindows, curr_pass_num, curr_parall_min, curr_parall_max);
     
      //real_end_currBin = (*end);

      beg_currBin = BEGIN(i, l->bin, tui_z, N);

      //real_end_currBin = END(i, l->bin, tui_z, w, N);
      real_end_currBin = END(beg_currBin, w, bin_size);
      if(real_end_currBin > N)
	real_end_currBin = N;

      neb = 0;

      //if (BEGIN(i, l->bin, tui_z, N) >= (*end))
      if(beg_currBin >= (*end))
	//bin is non-overlapping
	{
	  if(real_end_currBin - beg_currBin >= (w-tui_erro))
	    {
	      /* EMPTY BLOCK */
	      // a block has to be count only if it is not an
	      // empty block
	      //
	      // in the first pass: the empty-block info is available
	      // in goodWindows only for blocks of index less than the
	      // block containing the current windows (currBin)
	      //
	      // in successive passes: the empty-block info is significative
	      // also for blocks of index greater than currBin
	      //
	      // in either cases, if the \\ of the bin is the same
	      // of parall of the window we cannot use the fact that it is empty 
	      // because it depends also from the current window (in particular
	      // in pass successive to the first one, it was not empty at previous pass 
	      // because it contains at least the current window (kept in previous pass)
	      // [but it could be reset to empty block from some previous window in the
	      // same \\ in the current pass]
	           
	      parall_ind = beg_currBin >> tui_z;
	           
	      if(((parall_ind == curr_parall_min) || (parall_ind == curr_parall_max)) 
		 ||
		 ((curr_pass_num==1) && 
		  (((parall_ind < curr_parall_min) && ((goodWindows[parall_ind]).notEmpty!=0))
		   || (parall_ind > curr_parall_max)))
		 || 
		 ((curr_pass_num > 1) && ((goodWindows[parall_ind]).notEmpty!=0))) {
		     
		result++;
		       
		//*begin = BEGIN(i, l->bin, tui_z, N);
		//(*begin) = beg_currBin;
		//MOD
		(*begin) = beg_currBin + (w-tui_erro);
		(*end) = real_end_currBin;
	      }
	    }
	}
      else // bin could be overlapping 
	{
	  if(beg_currBin > (*begin))
	    (*begin) = beg_currBin;
	   
	  //intervalSize = (END(i, l->bin, tui_z, w, N)) - (*begin);
	  intervalSize = real_end_currBin - (*begin);
	   
	  if (intervalSize >= (w-tui_erro)) // bin is non-overlapping 
	    { 
	      n = intervalSize / (w-tui_erro);         // the weight of each interval
	           
	      begTemp = (*begin);
	           
	      for(j=1; j<=n; j++){
		       
		parall_ind = begTemp >> tui_z;
		/* EMPTY BLOCK */
		if(((parall_ind == curr_parall_min) || (parall_ind == curr_parall_max)) 
		     ||
		   ((curr_pass_num==1) && 
		    (((parall_ind < curr_parall_min) && ((goodWindows[parall_ind]).notEmpty!=0))
		     || (parall_ind > curr_parall_max)))
		     || 
		   ((curr_pass_num > 1) && ((goodWindows[parall_ind]).notEmpty!=0))) {
		   
		  result++;
		   
		  neb=j;
		}
		       
		begTemp = begTemp + (w-tui_erro);
	      }
	           
	      //result = result + n;
	           
	      //(*begin) = (*begin) + n * (w-tui_erro);  /* the rest */
	      (*begin) = (*begin) + neb * (w-tui_erro);  /* the rest */ 
	      //neb is the LAST not empty block
	      (*end) = real_end_currBin;
	    }
	  //else{
	  // bin is overlapping
	  //}
	}
     
      //(*end) = real_end_currBin;
     
      return result + Nelems(begin, end, l->left, i, w, bin_size, N, goodWindows, curr_pass_num, curr_parall_min, curr_parall_max);
    }
}
            
 
